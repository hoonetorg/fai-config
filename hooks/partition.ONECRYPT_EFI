#!/usr/bin/env -S python3 -u
import logging

import os
from pathlib import Path
import sys
import subprocess
import shlex
from typing import Any

import json
import time


def subprocess_run_wrapper(command: str, dryrun: bool = False, **kwargs) -> subprocess.CompletedProcess | None:
    if kwargs.get("shell"):
        cmd = command
    else:
        cmd = shlex.split(command)

    if dryrun:
        logging.info(f"[DRYRUN] {command}")
        return None

    logging.info(f"[EXECUTING] {command}")
    return subprocess.run(cmd, **kwargs)

def write_ks_snippets(diskpath: str):
    # Persist the disk identifier without newline
    with open('/tmp/disk-id', 'w') as f:
        f.write(diskpath)
    
    # Generate partitions.ks Kickstart fragment
    partitions_ks = f"""
    ignoredisk --only-use={diskpath}
    part /boot/efi --fstype="efi" --onpart={diskpath}-part1 --fsoptions="umask=0077,shortname=winnt"
    part btrfs.2 --fstype="btrfs" --onpart={diskpath}-part2
    part btrfs.3 --fstype="btrfs" --onpart={diskpath}-part3 --encrypted --luks-version=luks2
    
    btrfs /boot --label=fedora_boot --data=single btrfs.2
    btrfs none --label=fedora_fedora --data=single btrfs.3
    
    btrfs / --subvol --name=root fedora_fedora
    btrfs /var --subvol --name=var fedora_fedora
    btrfs /home --subvol --name=home fedora_fedora
    """
    with open('/tmp/partitions.ks', 'w') as f:
        f.write(partitions_ks)
    
    # Debug output for partitions.ks
    logging.info(f"Generated /tmp/partitions.ks:\n{partitions_ks}")

def get_disk_info(diskpath: str, dryrun: bool = False) -> Any:
    # Gather disk info via lsblk
    lsblk_cmd = (
         "lsblk --bytes -Jo "
         "DISK-SEQ,NAME,KNAME,PKNAME,PATH,ID-LINK,SCHED,SIZE,START,PTTYPE,"
         "TYPE,PARTN,PARTTYPE,PARTTYPENAME,PARTFLAGS,PARTLABEL,FSTYPE,"
         "FSROOTS,MOUNTPOINTS "
         f"{shlex.quote(diskpath)}" 
    )
    try:
        result = subprocess_run_wrapper(
            command=lsblk_cmd,
            dryrun=dryrun,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=True
        )

        if dryrun or result is None:
            return None

        raw = result.stdout
        logging.info(f"Raw lsblk output:\n{raw}")
    except subprocess.CalledProcessError as err:
        logging.error(f"lsblk failed: {err.stderr}")
        sys.exit(1)
    
    # Parse JSON
    logging.info(f"Parsed JSON:")
    try:
        data = json.loads(raw)
        logging.info(f"JSON loads lsblk output:\n{json.dumps(data, indent=2)}")
    except json.JSONDecodeError as err:
        logging.error(f"Failed to parse JSON: {err}")
        sys.exit(1)
    
    # Check if blockdevice
    block_devices = data.get("blockdevices")

    if not block_devices:
        logging.error(f"No blockdevices entry for {diskpath}")
        return block_devices
    if len(block_devices) != 1:
        logging.error(f"Expected exactly one blockdevice entry for {diskpath}, found {len(block_devices)}")
        return False

    logging.info(f"Found blockdevices entry for {diskpath}")
    return block_devices[0]

def check_should_partition(diskpath: str, disk_info: dict ) -> bool:
    
    # Check if disk
    disk_type = disk_info.get("type")
    if disk_type != "disk":
        logging.error(f"{diskpath} is type={disk_type}, not a disk")
        sys.exit(1)
    
    logging.info(f"{diskpath} is confirmed as a whole disk.")
    
    should_partition = False
    
    # Check for existing partition table
    disk_pttype = disk_info.get("pttype")
    if disk_pttype:
        logging.info(f"{diskpath} has existing partition table type '{disk_pttype}'; skipping partitioning")
        should_partition = False
    else:
      # No partition table
      logging.info(f"{diskpath} has no partition table, partition table type is '{disk_pttype}'.")
    
    
      # Further check for a filesystem directly on the disk
      disk_fstype = disk_info.get("fstype")
      if disk_fstype:
          logging.info(f"{diskpath} has existing filesystem '{disk_fstype}'; skipping partitioning")
          should_partition = False
      else:
          logging.info(f"No filesystem detected on {diskpath}")
          # This is the only condition where we do partitioning - no partition table and no FS
          should_partition = True
    
    # Furhter check for existing partitions - should only be True when disk has partition table
    if disk_info.get("children"):
        should_partition = False
    else:
        logging.info(f"{diskpath} has no partitions.")

    return should_partition

def do_device_settle(dryrun: bool = False):
    # Wait for udev to settle
    for ucmd in ['trigger', 'settle']:
        subprocess_run_wrapper(command=f"udevadm {shlex.quote(ucmd)}", dryrun=dryrun)
        time.sleep(5)
    
    
def do_wipe_parts(diskpath: str, disk_info: dict, wipe_parts: list, dryrun: bool = False) -> bool:
    disk_id_link = disk_info.get('id-link')
    disk_parts = disk_info.get("children")
    disk_pttype = disk_info.get("pttype")
    if  disk_parts:
        # If GPT exists or partitions exist, wipe partitions defined in wipe_parts
        if disk_pttype in [ 'gpt' ] and disk_parts:
            for p in disk_parts:
                part_id_link = p.get("id-link")
                partnumber = p.get("partno") or p.get("partn")
                part_path = f"/dev/disk/by-id/{part_id_link}"
                logging.info(f"{diskpath} has existing partition: {part_path}")
                #if part_id_link in [f"{disk_id_link}-part{i}" for i in wipe_parts]:
                if partnumber and (int(partnumber) in wipe_parts):
                    subprocess_run_wrapper(command=f"wipefs --force --all {shlex.quote(part_path)}", dryrun=dryrun)
            logging.info(f"signatures wiped on parts {wipe_parts} wiped.")
    
        subprocess_run_wrapper(command=f"partprobe {shlex.quote(diskpath)}", dryrun=dryrun)
        do_device_settle(dryrun=dryrun)

def do_partition(diskpath: str, root_end_mib: int, dryrun: bool = False):
    # Disk is valid and empty â€“ now partition it
    logging.info(f"Partitioning {diskpath}")
    subprocess_run_wrapper(command=(
        "parted --script "
        f"{shlex.quote(diskpath)} "
        "unit MiB "
        "mklabel gpt "
        "mkpart primary 1 2048 "
        "mkpart primary 2048 4096 "
        f"mkpart primary 4096 {shlex.quote(str(root_end_mib))} "
        "set 1 boot on "
        "set 1 esp on "
        "set 2 bls_boot on "
        f"name 1 {shlex.quote("'EFI System Partition'")} "
        f"name 2 {shlex.quote("''")} "
        f"name 3 {shlex.quote("''")}"
        ),
        dryrun=dryrun)

    do_device_settle(dryrun=dryrun)

    # Show free space after partitioning
    logging.info(f"Current partition layout (free space):")
    subprocess_run_wrapper(command=(
        "parted --script "
        f"{shlex.quote(diskpath)} "
        "unit MiB print free"
        ),
        dryrun=dryrun)

def do_cryptsetup(partition: str, cryptpassword: str, dryrun: bool = False) -> str:
 
    password=(cryptpassword + "\n").encode()
    subprocess_run_wrapper(command=(
        "cryptsetup luksFormat " 
        "--type luks2 " 
        "--batch-mode "
        "-c aes-xts-plain64 "
        "-s 512 "
        "-h sha512 "
        "-i 5000 "
        "--use-random "
        "--align-payload 2048 "
        f"{shlex.quote(partition)}" 
        ),
        dryrun=dryrun,
        input=password,
        check=True
    )

    do_device_settle(dryrun=dryrun)

    result = subprocess_run_wrapper(
        command=f"blkid -s UUID -o value {shlex.quote(partition)}",
        dryrun=dryrun,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True
        )

    if dryrun or result is None:
        return None

    uuid = result.stdout.strip()

    subprocess_run_wrapper(command=(
        "cryptsetup open " 
        "--type luks2 " 
        "--batch-mode "
        "--allow-discards "
        f"{shlex.quote(partition)} " 
        f"luks-{shlex.quote(uuid)}"
        ), 
        dryrun=dryrun,
        input=password,
        check=True
    )

    do_device_settle(dryrun=dryrun)
 
    logging.info(f"Created LUKS device on {partition} with UUID {uuid} and opened it as luks-{uuid}")

    return uuid


def do_mkfs(part: str, parttype: str, dryrun: bool = False) -> str:
    match parttype:
        case 'EFI':
            subprocess_run_wrapper(command=f"mkfs.vfat -F 32 {shlex.quote(part)}", dryrun=dryrun)
        case 'btrfs':
            subprocess_run_wrapper(command=f"mkfs.btrfs -d single -m dup {shlex.quote(part)}", dryrun=dryrun)
        case _:
            logging.error(f"Unsupported parttype {parttype} - exiting")
            sys.exit(1)

    result = subprocess_run_wrapper(
        command=f"blkid -s UUID -o value {shlex.quote(part)}",
        dryrun=dryrun,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True
        )

    if dryrun or result is None:
        return None

    uuid = result.stdout.strip()

    logging.info(f"Formatted partition {part} as {parttype} with UUID {uuid}")

    return uuid

def do_btrfs_subvols(part: str, subvolumes: list, dryrun: bool = False):
    mountpoint = "/btrfs"
    logging.info(f"Mounting {part} at {mountpoint}")
    os.makedirs(mountpoint, exist_ok=True)
    subprocess_run_wrapper(command=f"mount -o rw,subvolid=5,compress=zstd:1,discard=async {shlex.quote(part)} {shlex.quote(mountpoint)}", dryrun=dryrun)
    try:
        for sub in subvolumes:
            path = os.path.join(mountpoint, sub)
            logging.info(f"Creating btrfs subvolume {path}")
            subprocess_run_wrapper(command=f"btrfs subvolume create {shlex.quote(path)}", dryrun=dryrun)
    finally:
        logging.info(f"Unmounting {mountpoint}")
        subprocess_run_wrapper(command=f"umount {shlex.quote(mountpoint)}", dryrun=dryrun)
        os.rmdir(mountpoint)


def do_write_disk_var_sh(esppart: str, bootpart: str, rootpart: str, bootdev: str):
    disk_var_sh = os.path.join(os.environ['LOGDIR'], "disk_var.sh")
    with open(disk_var_sh, "w") as f:
        f.write(f'ESP_DEVICE="{esppart}"\n')
        f.write(f'BOOT_PARTITION="{bootpart}"\n')
        f.write(f'ROOT_PARTITION="{rootpart}"\n')
        f.write(f'SWAPLIST=""\n')
        f.write(f'BOOT_DEVICE="{bootdev}"\n')
        f.write(f'PHYSICAL_BOOT_DEVICES="{bootdev}"\n')

def do_write_crypttab(crypt_uuids: list):
    crypttab = os.path.join(os.environ['LOGDIR'], "crypttab")
    for crypt_uuid in crypt_uuids: 
        with open(crypttab, "w") as f:
            f.write(f'luks-{crypt_uuid} UUID={crypt_uuid} none luks,discard\n')


def do_write_fstab(efi_uuid: str, boot_uuid: str, root_uuid: str):
    fstab = os.path.join(os.environ['LOGDIR'], "fstab")
    with open(fstab, "w") as f:
        f.write(f"UUID={root_uuid} /         btrfs   rw,subvol=os,compress=zstd:1,x-systemd.device-timeout=0,discard=async 0 1\n")
        f.write(f"UUID={boot_uuid} /boot    btrfs   rw,subvol=boot,compress=zstd:1,x-systemd.device-timeout=0,discard=async  0 2\n")
        f.write(f"UUID={efi_uuid} /boot/efi vfat    rw,discard             0 2\n")

def do_setup_storage(diskpath: str):
    crypt_root_uuid = do_cryptsetup(partition=f"{diskpath}-part3", cryptpassword="hoonetorg")

    efi_uuid = do_mkfs(part=f"{diskpath}-part1", parttype="EFI")
    boot_uuid = do_mkfs(part=f"{diskpath}-part2", parttype="btrfs")
    root_uuid = do_mkfs(part=f"/dev/mapper/luks-{crypt_root_uuid}", parttype="btrfs")

    do_btrfs_subvols(part=f"{diskpath}-part2", subvolumes=[ 'boot' ])
    do_btrfs_subvols(part=f"/dev/mapper/luks-{crypt_root_uuid}", subvolumes=[ 'os' ])

    do_write_disk_var_sh(esppart=f"{diskpath}-part1", bootpart=f"{diskpath}-part2", rootpart=f"/dev/mapper/luks-{crypt_root_uuid}", bootdev=f"{diskpath}")

    do_write_crypttab(crypt_uuids=[ crypt_root_uuid ])

    do_write_fstab(efi_uuid=efi_uuid, boot_uuid=boot_uuid, root_uuid=root_uuid)


def main():
    dryrun = False
    logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')

    ks = os.path.isdir("/usr/share/anaconda")
    fai = os.path.isdir("/var/lib/fai")
    if ks and fai:
        logging.error(f"Found both Anaconda dir and FAI dir - can only be either or")
        sys.exit(1)

    diskpath = "/dev/disk/by-id/scsi-0QEMU_QEMU_HARDDISK_drive-scsi0-0-0-0"
    rootsizemib = 20480
    root_end_mib = 2048 + 2048 + rootsizemib # efi size + boot size + rootsizemib
    wipe_parts = [ 1, 2, 3 ]

    disk_info = get_disk_info(diskpath=diskpath, dryrun=dryrun)

    if not disk_info:
        logging.error(f"Couldn't get diskinfo {diskpath}")
        sys.exit(1)

    should_partition = check_should_partition(diskpath=diskpath, disk_info=disk_info)

    if disk_info.get("children"):
        wiped = do_wipe_parts(diskpath=diskpath, disk_info=disk_info, wipe_parts=wipe_parts)

    if should_partition:
        do_partition(diskpath=diskpath, root_end_mib=root_end_mib)
    else:
        logging.info(f"Partitioning skipped.")
    
    if ks:
        write_ks_snippets(diskpath=diskpath)
    elif fai:
        do_setup_storage(diskpath)
        subprocess_run_wrapper(command=f"skiptask partition", dryrun=dryrun, shell=True, executable="/bin/bash", check=True)

if __name__ == "__main__":
    main()
